import { Fragment as _Fragment, jsx as _jsx } from "react/jsx-runtime";
import { Children, useMemo } from 'react';
import { Internals, Sequence, useCurrentFrame, useVideoConfig } from 'remotion';
import { flattenChildren } from './flatten-children.js';
import { slide } from './presentations/slide.js';
import { validateDurationInFrames } from './validate.js';
// eslint-disable-next-line react/function-component-definition
const TransitionSeriesTransition = function (
// eslint-disable-next-line @typescript-eslint/no-unused-vars
_props) {
    return null;
};
const SeriesSequence = ({ children }) => {
    // eslint-disable-next-line react/jsx-no-useless-fragment
    return _jsx(_Fragment, { children: children });
};
const TransitionSeriesChildren = ({ children, }) => {
    const { fps } = useVideoConfig();
    const frame = useCurrentFrame();
    const childrenValue = useMemo(() => {
        let transitionOffsets = 0;
        let startFrame = 0;
        const flattedChildren = flattenChildren(children);
        return Children.map(flattedChildren, (child, i) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const current = child;
            if (typeof current === 'string') {
                // Don't throw if it's just some accidential whitespace
                if (current.trim() === '') {
                    return null;
                }
                throw new TypeError(`The <TransitionSeries /> component only accepts a list of <TransitionSeries.Sequence /> components as its children, but you passed a string "${current}"`);
            }
            const hasPrev = flattedChildren[i - 1];
            const nextPrev = flattedChildren[i + 1];
            const prev = typeof hasPrev === 'string' || typeof hasPrev === 'undefined'
                ? null
                : hasPrev.type === TransitionSeriesTransition
                    ? hasPrev
                    : null;
            const next = typeof nextPrev === 'string' || typeof nextPrev === 'undefined'
                ? null
                : nextPrev.type === TransitionSeriesTransition
                    ? nextPrev
                    : null;
            const prevIsTransition = typeof hasPrev === 'string' || typeof hasPrev === 'undefined'
                ? false
                : hasPrev.type === TransitionSeriesTransition;
            if (current.type === TransitionSeriesTransition) {
                if (prevIsTransition) {
                    throw new TypeError(`A <TransitionSeries.Transition /> component must not be followed by another <TransitionSeries.Transition /> component (nth children = ${i - 1} and ${i})`);
                }
                return null;
            }
            if (current.type !== SeriesSequence) {
                throw new TypeError(`The <TransitionSeries /> component only accepts a list of <TransitionSeries.Sequence /> and <TransitionSeries.Transition /> components as its children, but got ${current} instead`);
            }
            const castedChildAgain = current;
            const debugInfo = `index = ${i}, duration = ${castedChildAgain.props.durationInFrames}`;
            if (!(castedChildAgain === null || castedChildAgain === void 0 ? void 0 : castedChildAgain.props.children)) {
                throw new TypeError(`A <TransitionSeries.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);
            }
            const durationInFramesProp = castedChildAgain.props.durationInFrames;
            const { durationInFrames, children: _children, ...passedProps } = castedChildAgain.props;
            validateDurationInFrames(durationInFramesProp, {
                component: `of a <TransitionSeries.Sequence /> component`,
                allowFloats: true,
            });
            const offset = (_a = castedChildAgain.props.offset) !== null && _a !== void 0 ? _a : 0;
            if (Number.isNaN(offset)) {
                throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);
            }
            if (!Number.isFinite(offset)) {
                throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);
            }
            if (offset % 1 !== 0) {
                throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);
            }
            const currentStartFrame = startFrame + offset;
            let duration = 0;
            if (prev) {
                duration = prev.props.timing.getDurationInFrames({
                    fps,
                });
                transitionOffsets -= duration;
            }
            let actualStartFrame = currentStartFrame + transitionOffsets;
            startFrame += durationInFramesProp + offset;
            // Handle the case where the first item is a transition
            if (actualStartFrame < 0) {
                startFrame -= actualStartFrame;
                actualStartFrame = 0;
            }
            const nextProgress = next
                ? next.props.timing.getProgress({
                    frame: frame -
                        actualStartFrame -
                        durationInFrames +
                        next.props.timing.getDurationInFrames({ fps }),
                    fps,
                })
                : null;
            const prevProgress = prev
                ? prev.props.timing.getProgress({
                    frame: frame - actualStartFrame,
                    fps,
                })
                : null;
            if (next &&
                durationInFramesProp < next.props.timing.getDurationInFrames({ fps })) {
                throw new Error(`The duration of a <TransitionSeries.Sequence /> must not be shorter than the duration of the next <TransitionSeries.Transition />. The transition is ${next.props.timing.getDurationInFrames({ fps })} frames long, but the sequence is only ${durationInFramesProp} frames long (${debugInfo})`);
            }
            if (prev &&
                durationInFramesProp < prev.props.timing.getDurationInFrames({ fps })) {
                throw new Error(`The duration of a <TransitionSeries.Sequence /> must not be shorter than the duration of the previous <TransitionSeries.Transition />. The transition is ${prev.props.timing.getDurationInFrames({ fps })} frames long, but the sequence is only ${durationInFramesProp} frames long (${debugInfo})`);
            }
            if (next && prev && nextProgress !== null && prevProgress !== null) {
                const nextPresentation = (_b = next.props.presentation) !== null && _b !== void 0 ? _b : slide();
                const prevPresentation = (_c = prev.props.presentation) !== null && _c !== void 0 ? _c : slide();
                const UppercaseNextPresentation = nextPresentation.component;
                const UppercasePrevPresentation = prevPresentation.component;
                return (_jsx(Sequence, { name: passedProps.name || '<TS.Sequence>', from: Math.floor(actualStartFrame), durationInFrames: durationInFramesProp, layout: "none", stack: passedProps.stack, children: _jsx(UppercaseNextPresentation, { passedProps: (_d = nextPresentation.props) !== null && _d !== void 0 ? _d : {}, presentationDirection: "exiting", presentationProgress: nextProgress, children: _jsx(UppercasePrevPresentation, { passedProps: (_e = prevPresentation.props) !== null && _e !== void 0 ? _e : {}, presentationDirection: "entering", presentationProgress: prevProgress, children: _jsx(Sequence, { showInTimeline: false, ...passedProps, children: child }) }) }) }));
            }
            if (prevProgress !== null && prev) {
                const prevPresentation = (_f = prev.props.presentation) !== null && _f !== void 0 ? _f : slide();
                const UppercasePrevPresentation = prevPresentation.component;
                return (_jsx(Sequence, { name: passedProps.name || '<TS.Sequence>', from: Math.floor(actualStartFrame), durationInFrames: durationInFramesProp, layout: "none", stack: passedProps.stack, children: _jsx(UppercasePrevPresentation, { passedProps: (_g = prevPresentation.props) !== null && _g !== void 0 ? _g : {}, presentationDirection: "entering", presentationProgress: prevProgress, children: _jsx(Sequence, { showInTimeline: false, ...passedProps, children: child }) }) }));
            }
            if (nextProgress !== null && next) {
                const nextPresentation = (_h = next.props.presentation) !== null && _h !== void 0 ? _h : slide();
                const UppercaseNextPresentation = nextPresentation.component;
                return (_jsx(Sequence, { name: passedProps.name || '<TS.Sequence>', from: Math.floor(actualStartFrame), durationInFrames: durationInFramesProp, layout: "none", stack: passedProps.stack, children: _jsx(UppercaseNextPresentation, { passedProps: (_j = nextPresentation.props) !== null && _j !== void 0 ? _j : {}, presentationDirection: "exiting", presentationProgress: nextProgress, children: _jsx(Sequence, { showInTimeline: false, ...passedProps, children: child }) }) }));
            }
            return (_jsx(Sequence, { name: passedProps.name || '<TS.Sequence>', from: Math.floor(actualStartFrame), durationInFrames: durationInFramesProp, ...passedProps, children: child }));
        });
    }, [children, fps, frame]);
    // eslint-disable-next-line react/jsx-no-useless-fragment
    return _jsx(_Fragment, { children: childrenValue });
};
const TransitionSeries = ({ children, name, ...otherProps }) => {
    const displayName = name !== null && name !== void 0 ? name : '<TransitionSeries>';
    return (_jsx(Sequence, { name: displayName, ...otherProps, children: _jsx(TransitionSeriesChildren, { children: children }) }));
};
TransitionSeries.Sequence = SeriesSequence;
TransitionSeries.Transition = TransitionSeriesTransition;
export { TransitionSeries };
Internals.addSequenceStackTraces(TransitionSeries);
Internals.addSequenceStackTraces(SeriesSequence);
