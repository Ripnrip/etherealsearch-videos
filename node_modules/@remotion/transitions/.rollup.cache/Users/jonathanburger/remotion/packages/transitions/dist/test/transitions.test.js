import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * @vitest-environment jsdom
 */
import { makeMockCompositionManagerContext, makeTimelineContext, } from '@remotion/test-utils';
import { renderToString } from 'react-dom/server';
import { AbsoluteFill, Internals } from 'remotion';
import { expect, test } from 'vitest';
import { fade } from '../presentations/fade.js';
import { linearTiming } from '../timings/linear-timing.js';
import { TransitionSeries } from '../TransitionSeries.js';
const renderForFrame = (frame, markup) => {
    return renderToString(_jsx(Internals.CanUseRemotionHooksProvider, { children: _jsx(Internals.CompositionManager.Provider, { value: makeMockCompositionManagerContext(), children: _jsx(Internals.Timeline.TimelineContext.Provider, { value: makeTimelineContext(frame), children: markup }) }) }));
};
const Letter = ({ children, color }) => {
    return (_jsx(AbsoluteFill, { style: {
            backgroundColor: color,
            opacity: 0.9,
            justifyContent: 'center',
            alignItems: 'center',
            fontSize: 200,
            color: 'white',
        }, children: children }));
};
test('Should throw if two transitions in a row', () => {
    expect(() => {
        return renderForFrame(10, _jsxs(TransitionSeries, { children: [_jsx(TransitionSeries.Sequence, { durationInFrames: 60, children: _jsx(Letter, { color: "green", children: "C" }) }), _jsx(TransitionSeries.Transition, { presentation: fade({}), timing: linearTiming({
                        durationInFrames: 40,
                    }) }), _jsx(TransitionSeries.Transition, { presentation: fade({}), timing: linearTiming({
                        durationInFrames: 40,
                    }) })] }));
    }).toThrow('A <TransitionSeries.Transition /> component must not be followed by another <TransitionSeries.Transition /> component (nth children = 1 and 2)');
});
